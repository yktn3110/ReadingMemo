- [第1章 まずは基礎から](#第1章-まずは基礎から)
  - [## 1-1 Cはどんな言語なのか](#-1-1-cはどんな言語なのか)
  - [## 1-2 メモリとアドレス](#-1-2-メモリとアドレス)
  - [## 1-3 ポインタについて](#-1-3-ポインタについて)
  - [## 1-4 配列について](#-1-4-配列について)
- [第2章 Cはメモリをどう使うのか](#第2章-cはメモリをどう使うのか)
  - [## 2-1 仮想アドレス](#-2-1-仮想アドレス)
  - [## 2-2 Cのメモリの使い方](#-2-2-cのメモリの使い方)
  - [## 2-3 関数と文字列リテラル](#-2-3-関数と文字列リテラル)
  - [## 2-4 静的変数](#-2-4-静的変数)
  - [## 2-5 自動変数（スタック）](#-2-5-自動変数スタック)
  - [## 2-6 malloc()による動的な領域確保（ヒープ）](#-2-6-mallocによる動的な領域確保ヒープ)
  - [## 2-7 アラインメント](#-2-7-アラインメント)
  - [## 2-8 バイトオーダー](#-2-8-バイトオーダー)
- [第3章 Cの文法を解き明かす](#第3章-cの文法を解き明かす)
  - [## 3-1 Cの宣言を解読する](#-3-1-cの宣言を解読する)
  - [## 3-2 Cの型モデル](#-3-2-cの型モデル)
  - [## 3-3 式](#-3-3-式)
  - [## 3-4 続・Cの宣言を解読する](#-3-4-続cの宣言を解読する)
# 第1章 まずは基礎から

## 1-1 Cはどんな言語なのか
---
- CはもともとUNIXを開発する為に作られた言語。 
<br>
- C言語のバイブル、『The C Programming Language』（著者二人のイニシャルからK&Rと呼ばれる）がANSI C以前の事実上の標準だった。
<br>
- ANSI C(C89/90)は、1989年にANSI(米国規格協会)によって標準仕様案が採択され、1990年にISOの規格となった。
<br>
- C95ではワイド文字を扱うライブラリが追加された。
<br>
- C99では以下の様な機能らが追加された。
    - //での1行コメント
    - 変数をブロックの先頭でなくても宣言可
    - プリプロセッサの機能拡張
    - 複素数型、_Bool型といった型の追加
    - 型の指定が厳しくなり、宣言のない関数はintを消すものとするというルールの廃止
    - 要素指示子付きの初期化子
    - 複合リテラル
    - 可変長配列(VLA)
    - フレキシブル配列メンバ
<br>
- C11は、2011年に定められたCの規格であり、追加機能として、マルチスレッド対応、Unicodeサポート、無名共用体などがある。
<br>
- Cの理念：ANSIの企画にはRationale(理論的根拠)という文書が資料として付属していた。
  Rationaleの一節に「Keep the spirit of C」(Cの精神を保とう)という一節があり、以下のように「spirit of C」が紹介されている。
    - Trust the programmer.
    - Don't prevent the programmer from doing what needs to be done.
    - Keep the language small and simple.
    - Provide only way to do an operation.
    - Make it fast, even if it is not guaranteed to be portable.
  上記のようにCはプログラマーが全知全能であり、コンパイラを簡単に実装する事と、
  高速な実行コードを吐くソースが書けるかを優先して設計されている
<br>

## 1-2 メモリとアドレス
---
<br>

## 1-3 ポインタについて
---

- ポインタにnを加算するとポインタは「そのポインタがさす方のサイズ× n」だけ進む
<br>
- 何も指していない事を保証されているポインタをヌルポインタと呼ぶ。
  ヌルポインタを表す定数値として通常はマクロNULLを用いる。
  ヌルポインタは相手がどんな型を指すポインタであるか関わらず代入や比較が可能。
  その為、わざわざキャストしてから、代入や比較する事は無駄。　
<br>
- 0はコンパイラが文脈で判断してヌルポインタで扱う
<br>
- ポインタを使うケース
  1.関数から複数の値を返してもらう
  2.配列をアクセスする
  3.連結リストや木構造のようなデータ構造を表現する
<br>
- 値渡しで済むならポインタは必要ない
<br>

## 1-4 配列について
---
- 添字演算子[]は配列とは無関係（宣言時除く）
  以下の二つの記述は同様の意味を持つが、[]を書かないで書くと先頭要素へのポインタという意味になるという**わけではない**。
  []が在ろうがなかろうが式の中では、配列はその先頭要素へのポインタに読み替えられる。
  p[i]という記法は、*(p+i)の簡便記法である。
```c
p = &array[0];
p = array;
```
<br>

- ポインタ演算という機能の有用性
  下記のコードにおいて、上のfor分ではarray[i]が使用される度に、array + (i * 要素のサイズ)の処理を行っていては効率は悪くなるが、下のfor分のように記述すると*pに対する掛け算と足し算はループの終わり時のみで済む。その為、「ポインタを使うほうが一般に高速である」と言われる。
  然し、これは昔の環境の話であり、現在のコンパイラでは、ほぼ同じ機械コードが出力される。
```c
for (i = 0; i < LOOP_MAX; i++) {
  /* array[i]を使った処理 */
}

for (p = &array[0]; p != &array[LOOP_MAX]; p++) {
  /* *pを使った処理 */
}
```
<br>

# 第2章 Cはメモリをどう使うのか
## 2-1 仮想アドレス
---
- 今どきの環境なら、アプリケーションプログラムが見えるのは、仮想アドレス空間
<br>

## 2-2 Cのメモリの使い方
---

- malloc()で確保した領域はfree()するまでが寿命
<br>

## 2-3 関数と文字列リテラル
---

- 関数へのポインタを変数に格納する事は以下の様な際に用いる
  - GUIのボタンにボタンが押された際に呼び出される関数を覚えておいてもらう
  - 複雑な処理をライブラリ化するが、処理の一部だけをカスタマイズしたい場合
  - 関数へのポインタの配列により処理を振り分ける
<br>

## 2-4 静的変数
---

- ファイル内static変数やローカルなstatic変数は統合の必要はないが、リンカに何らかのアドレスを割り当ててもらう必要がある。よって、シンボルテーブルに記載される
<br>

## 2-5 自動変数（スタック）
---
- 呼び出し側が実引数の値をスタックに積む際は後ろから
<br>

- 関数コール時に、関数コールに関連する復帰情報をスタックに積む
<br>

- 配列の領域を大きく超えて書き込むことで、その関数の復帰情報を壊してしまい、関数から抜けれらなく事も考えられる
<br>

- バッファオーバーフロー脆弱性
<br>

- ANSI Cでは、移植性を高めるために、stdarg.hというヘッダファイルにおいて、可変長引数を使うためのマクロ群を提供している
``` C

/* 可変長引数の関数の例 */

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>

void tiny_printf(char *format, ...)
{
  int i;
  va_list ap;
  
  va_start(ap, format);
  for (i  = 0; format[i] != '\0'; i++)
  {
      switch (format[i])
      {
        case 's':
            printf("%s", va_arg(ap, char *));
            break;
        case 'd':
            printf("%d", va_arg(ap, int));
            break;
        default:
            assert(0);
            break;
      }
  }
  va_end(ap);
  putchar('\n');
}

int main(void)
{
    tiny_printf("sdd", "result...", 3, 5);

    return 0;
}
```
<br>

## 2-6 malloc()による動的な領域確保（ヒープ）
---

- malloc()の基礎
``` C
/* 引数で指定されたサイズのメモリの塊を確保する */
/* メモリ確保に失敗した場合はNULLを返す */
p = malloc(size);
/* freeによって使用後は領域を解放する */
free(p);
```
<br>

- 動的にメモリを割り当て、任意の順序で解放できる記憶領域のことをヒープ(heap)と呼ぶ
<br>

- free()して即座にその領域がOSに返されるわけではない。
  ポインタAを使ってある領域を参照している箇所で、その領域をfree()してしまったが、ポインタB経由でその領域を参照している際は、free()される前と同じ値がポインタB経由で見えるという事もあり得る。
  その後、どこか別の場所でmalloc()が実行され、この領域が割り当てられて初めて内容が壊れる。
<br>

- malloc()以外にもcalloc()という動的メモリ確保関数が存在する。
  calloc()では、領域の確保後、その領域をゼロクリアする。ただし全ビットをゼロクリアするだけであるので、doubleやfloatはゼロとなるかは処理系依存。
<br>

- realloc()というmalloc()ですでに割りつけられている領域のサイズを変更する為の関数も存在する。
領域を拡張する際は、後ろが必要なだけ空いていれば、そのままそこに領域を拡張する事ができるが、そうでない場合、新たな別のところに領域を確保して、そこに内容をコピーする。
要素を追加するごとにrealloc()で領域を確保すると頻繁に領域をコピーする事となり、効率が落ちる可能性がある。
<br>

## 2-7 アラインメント
---
- 型によっては配置できるアドレスに制限がある。あるいは配置する事はできても効率が悪くなるようなCPUもある。
そういう場合、コンパイラが適当に協会調整（アライアメント）を行い、構造体に適切にパディングを挿入する。
<br>

## 2-8 バイトオーダー
---
- データのメモリ上への配置方法がリトルエンディアンであるか、ビッグエンディアンであるかは、（もしくは切り替え可能なバイエンディアン）CPUにより異なる。
<br>

# 第3章 Cの文法を解き明かす
## 3-1 Cの宣言を解読する
---
- 宣言中の*,(),[]は演算子ではないし、優先順位も構文規則の中では、演算子の優先順位とは別の個所で定義されている。
<br>

- Cの宣言の解釈は以下の順序に従う事で機械的に英語で読み進む事ができる
  ① まず、識別子に着目
  ② 識別子に近いほうから、優先順位に従って派生型（ポインタ、配列、関数）を解釈
  　優先順位は 宣言をまとめる為の括弧 -> 配列を意味する[]関数を意味する() -> ポインタを意味する*
  ③ 派生型を解釈したら、それを「of」または「to」または「returning」で連結する
  ④ 最後に型指定子を追加する
<br>

## 3-2 Cの型モデル
---
- 配列は常に式の中ではポインタに読み替えられるが、これは配列へのポインタではない。
  配列へのポインタを表現する際は&をつけて書く
<br>

- C言語には多次元配列は存在しない。下記の宣言はintの配列（要素数2）の配列（要素数3）であり、たまたま派生元の型が配列であったというだけである
``` C
int hoge[3][2];
```
<br>

- 関数型はサイズが特定できない。その為、関数型から配列型を派生する事はできない。また、関数型を指すポインタに対しては、ポインタ演算ができない。（ポインタが指す先の型のサイズが特定できない為）

<br>

## 3-3 式
---
- 式がどこかの記憶領域を意味している場合、その式のことを左辺値(lvalue)と呼ぶ。それに対応して、式が異なる値を意味している場合は、その式を右辺値と呼ぶこともある。


- 演算子の優先順位
  優先順位が最も高い()は、関数呼び出しを意味する演算子であり、この場合の優先順位とはfunc(a,b)の様な式において、funcと(a,b)の間の結びつきを表す

| 演算子 |  |結合規則|
|---|---|---|
| 後置演算子 |  () [] . -> ++ -- <br> (type name){list}(C99から) |左から右|
|単項演算子|! ~ ++ -- + - * & sizeof|右から左|
|キャスト演算子|(type name)|右から左|
|乗除演算子|* / %|左から右|
|加減演算子|+ -|左から右|
|ビット単位のシフト演算子|<< >>|左から右|
|関係演算子|< <= > >=|左から右|
|等価演算子|== !=|左か右|
|ビット単位のAND演算子|&|左か右|
|ビット単位の排他OR演算子|^|左か右|
|ビット単位のOR演算子|\||左か右|
|論理AND演算子|&&|左か右|
|論理OR演算子|\|\||左か右|
|条件演算子|? :|右から左|
|代入演算子|= += -= *= /= %= &= ^=<br> \|= <<= >>=|右から左|
|コンマ演算子|,|左か右|

<br>

## 3-4 続・Cの宣言を解読する
---





