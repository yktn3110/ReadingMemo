- [第1章 まずは基礎から](#第1章-まずは基礎から)
  - [1-1 Cはどんな言語なのか](#1-1-cはどんな言語なのか)
  - [1-2 メモリとアドレス](#1-2-メモリとアドレス)
  - [1-3 ポインタについて](#1-3-ポインタについて)
  - [1-4 配列について](#1-4-配列について)
- [第2章 Cはメモリをどう使うのか](#第2章-cはメモリをどう使うのか)
  - [2-1 仮想アドレス](#2-1-仮想アドレス)
  - [2-2 Cのメモリの使い方](#2-2-cのメモリの使い方)
# 第1章 まずは基礎から

## 1-1 Cはどんな言語なのか

- CはもともとUNIXを開発する為に作られた言語。 
<br>
- C言語のバイブル、『The C Programming Language』（著者二人のイニシャルからK&Rと呼ばれる）がANSI C以前の事実上の標準だった。
<br>
- ANSI C(C89/90)は、1989年にANSI(米国規格協会)によって標準仕様案が採択され、1990年にISOの規格となった。
<br>
- C95ではワイド文字を扱うライブラリが追加された。
<br>
- C99では以下の様な機能らが追加された。
    - //での1行コメント
    - 変数をブロックの先頭でなくても宣言可
    - プリプロセッサの機能拡張
    - 複素数型、_Bool型といった型の追加
    - 型の指定が厳しくなり、宣言のない関数はintを消すものとするというルールの廃止
    - 要素指示子付きの初期化子
    - 複合リテラル
    - 可変長配列(VLA)
    - フレキシブル配列メンバ
<br>
- C11は、2011年に定められたCの規格であり、追加機能として、マルチスレッド対応、Unicodeサポート、無名共用体などがある。
<br>
- Cの理念：ANSIの企画にはRationale(理論的根拠)という文書が資料として付属していた。
  Rationaleの一節に「Keep the spirit of C」(Cの精神を保とう)という一節があり、以下のように「spirit of C」が紹介されている。
    - Trust the programmer.
    - Don't prevent the programmer from doing what needs to be done.
    - Keep the language small and simple.
    - Provide only way to do an operation.
    - Make it fast, even if it is not guaranteed to be portable.
  上記のようにCはプログラマーが全知全能であり、コンパイラを簡単に実装する事と、
  高速な実行コードを吐くソースが書けるかを優先して設計されている
<br>

## 1-2 メモリとアドレス
<br>

## 1-3 ポインタについて

- ポインタにnを加算するとポインタは「そのポインタがさす方のサイズ× n」だけ進む
<br>
- 何も指していない事を保証されているポインタをヌルポインタと呼ぶ。
  ヌルポインタを表す定数値として通常はマクロNULLを用いる。
  ヌルポインタは相手がどんな型を指すポインタであるか関わらず代入や比較が可能。
  その為、わざわざキャストしてから、代入や比較する事は無駄。　
<br>
- 0はコンパイラが文脈で判断してヌルポインタで扱う
<br>
- ポインタを使うケース
  1.関数から複数の値を返してもらう
  2.配列をアクセスする
  3.連結リストや木構造のようなデータ構造を表現する
<br>
- 値渡しで済むならポインタは必要ない
<br>

## 1-4 配列について

- 添字演算子[]は配列とは無関係（宣言時除く）
  以下の二つの記述は同様の意味を持つが、[]を書かないで書くと先頭要素へのポインタという意味になるという**わけではない**。
  []が在ろうがなかろうが式の中では、配列はその先頭要素へのポインタに読み替えられる。
  p[i]という記法は、*(p+i)の簡便記法である。
```c
p = &array[0];
p = array;
```
<br>

- ポインタ演算という機能の有用性
  下記のコードにおいて、上のfor分ではarray[i]が使用される度に、array + (i * 要素のサイズ)の処理を行っていては効率は悪くなるが、下のfor分のように記述すると*pに対する掛け算と足し算はループの終わり時のみで済む。その為、「ポインタを使うほうが一般に高速である」と言われる。
  然し、これは昔の環境の話であり、現在のコンパイラでは、ほぼ同じ機械コードが出力される。
```c
for (i = 0; i < LOOP_MAX; i++) {
  /* array[i]を使った処理 */
}

for (p = &array[0]; p != &array[LOOP_MAX]; p++) {
  /* *pを使った処理 */
}
```
<br>

# 第2章 Cはメモリをどう使うのか
## 2-1 仮想アドレス

- 今どきの環境なら、アプリケーションプログラムが見えるのは、仮想アドレス空間
<br>

## 2-2 Cのメモリの使い方

- malloc()で確保した領域はfree()するまでが寿命
<br>

- C言語では文字列はcharの配列
<br>

- ファイル内static変数やローカルなstatic変数は統合の必要はないが、リンカに何らかのアドレスを割り当ててもらう必要がある。
よって、シンボルテーブルに記載される
<br>

- 呼び出し側が実引数の値をスタックに積む際は後ろから
<br>

- 関数コール時に、関数コールに関連する復帰情報をスタックに積む
<br>

- 配列の領域を大きく超えて書き込むことで、その関数の復帰情報を壊してしまい、関数から抜けれらなく事も考えられる
<br>

- バッファオーバーフロー脆弱性
<br>


